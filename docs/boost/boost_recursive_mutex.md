[谈谈recursive_mutex(递归式互斥量)](https://blog.csdn.net/huang_xw/article/details/8458061)  
如果一个线程中可能在执行中需要再次获得锁的情况,按常规的做法会出现死锁。  
```
boost::recursive_mutex g_rec_mutex;  
boost::recursive_mutex::scoped_lock lock(g_rec_mutex);  
        // 当然这种写法也可以  
        // boost::lock_guard<boost::recursive_mutex> lock(g_rec_mutex);
```		
[什么是死锁及死锁的必要条件和解决方法](https://blog.csdn.net/abigale1011/article/details/6450845)
- 死锁产生的4个必要条件
 1. 互斥条件  
 如独木桥就是一种独占资源，两方的人不能同时过桥。
 2. 不可抢占条件  
 如过独木桥的人不能强迫对方后退，也不能非法地将对方推下桥，必须是桥上的人自己过桥后空出桥面（即主动释放占有资源），对方的人才能过桥。
 3. 占有且申请条件
 还以过独木桥为例，甲乙两人在桥上相遇。甲走过一段桥面（即占有了一些资源），还需要走其余的桥面（申请新的资源），但那部分桥面被乙占有（乙走过一段桥面）。甲过不去，前进不能，又不后退；乙也处于同样的状况。
 4. 循环条件
 就像前面的过独木桥问题，甲等待乙占有的桥面，而乙又等待甲占有的桥面，从而彼此循环等待。
 
- 避免死锁
 1. 安全序列
 2. 银行家算法 >银行家算法是从当前状态出发，逐个按安全序列检查各客户谁能完成其工作，然后假定其完成工作且归还全部贷款，再进而检查下一个能完成工作的客户，......。如果所有客户都能完成工作，则找到一个安全序列，银行家才是安全的。

